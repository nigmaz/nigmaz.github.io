import pefile, os, re, json

most_common_dlls = [
    "kernel32.dll",
    "ws2_32.dll",
    "ntdll.dll",
    "user32.dll",
    "advapi32.dll",
    "gdi32.dll",
    "shell32.dll",
    "ole32.dll",
    "oleaut32.dll",
    "comdlg32.dll",
    "comctl32.dll",
    "shlwapi.dll",
    "advpack.dll",
    "crypt32.dll",
    "iphlpapi.dll",
    "wininet.dll",
    "winhttp.dll",
    "mpr.dll",
    "psapi.dll",
    "urlmon.dll",
    "netapi32.dll",
    "bcrypt.dll",
    "gdiplus.dll",
    "wtsapi32.dll",
    "winspool.drv",
]

win_path = os.environ["WINDIR"]
system32_path = os.path.join(win_path, "system32")


def hash_131(s: str) -> int:
    h = 0
    bs = s
    for b in bs:
        if b == 0:
            break
        c = b
        if c <= 0x60:
            c = (c + 0x20) & 0xFF
        h = (h * 131 + c) & 0xFFFFFFFF
    return h


def get_functions(dll_path):
    pe = pefile.PE(dll_path)
    if (not hasattr(pe, "DIRECTORY_ENTRY_EXPORT")) or (
        pe.DIRECTORY_ENTRY_EXPORT is None
    ):
        print("[-] No exports for %s" % dll_path)
        return []
    else:
        expname = []
        for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
            if exp.name:
                expname.append(exp.name)
        return expname


data = {}
for dll in most_common_dlls:
    dll_path = os.path.join(system32_path, dll)
    dll_name = dll.split(".")[0].lower()
    if os.path.isfile(dll_path):
        for f in get_functions(dll_path):
            f_name = re.sub(r"\W+", "_", f.decode("utf-8"))
            name = "func_" + dll_name + "_" + f_name
            data[hash_131(f)] = name
        print("[+] Generated functions for %s" % dll_path)
    else:
        print("[+] File not found: %s" % dll_path)

with open("generated_api_hashes.json", "w") as f:
    f.write(json.dumps(data))
    f.close()

print("[+] All done! Check your generated_api_hashes.json file!!")
